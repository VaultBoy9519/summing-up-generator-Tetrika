const algo = 'RSA-OAEP';
const crypto = window.crypto.subtle;
const name = { name: algo }; // saves a few lines in the one-liners

// mini crypto module

// internal utils
const generateKey = () => (
  crypto.generateKey({ name: algo, modulusLength: 2048, publicExponent: new Uint8Array([0x01, 0x00, 0x01]), hash: { name: 'SHA-256' } }, true, ['encrypt', 'decrypt'])
);

const bufferize = msg => new Uint32Array(Array.from(JSON.stringify(msg)).map(c => c.charCodeAt(0)));
const debufferize = bfr => JSON.parse(String.fromCharCode.apply(null, new Uint32Array(bfr)));
const importKey = key => crypto.importKey(name, 'jwk', JSON.parse(key));
const exportKey = key => crypto.exportKey(name, 'jwk', key).then(JSON.stringify);
const encrypt = (key, msg) => crypto.encrypt(name, key.publicKey, bufferize(msg));
const decrypt = (key, msg) => crypto.decrypt(name, key.privateKey, msg).then(debufferize);

const { keys, assign } = Object;
const mapValues = (obj, mapper) => (
  keys(obj).reduce((res, key) => assign(res, { [key]: mapper(obj[key]) }, {}))
);

// returns a function that encapsulates operations on a single key
module.exports = () => {
  let keyPromise = null;
  // public methods with global key
  const getKey = () => { if (!keyPromise) keyPromise = generateKey(); return keyPromise; };
  // wraps async function in proxy that passes getKey() as the first arg
  const curryWithKey = fn => (...args) => getKey().then(key => fn(key, ...args));
  const exportedFunctions = { encrypt, decrypt, exportKey, importKey };
  return mapValues(exportedFunctions, curryWithKey);
};
